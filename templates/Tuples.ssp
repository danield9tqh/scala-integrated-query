package siq

<%
  val max_tuple_size = 20
  def p( max : Int, template: String ) = Range( 1, max+1 ).map( i=>template.format(i,i) ).mkString(",")
%>

// FIXME: move overloadhack to its own file
trait OverloadHack{
  class Overloaded0
  implicit val overloaded0 = new Overloaded0
#for (i <- 1 to max_tuple_size+5)
  class Overloaded${i}
  implicit val overloaded${i} = new Overloaded${i}
#end
}

trait ITuples extends IModuleBase with OverloadHack{
  this: IComprehensions =>
  // This allows accessing a Rep[TupleX[_]]'s elements
#for (i <- 1 to max_tuple_size)
  implicit def rep2tuple${i}[${p(i,"T%s")}]( t:Rep[Tuple${i}[${p(i,"T%s")}]] ) : Tuple${i}[${p(i,"Rep[T%s]")}]
#end

  // This turns tuples into Reps (which is required, as we only want the outer most element to officially have type Rep[...])
#for (i <- 1 to max_tuple_size)
  implicit def tuple2rep${i}[${p(i,"T%s")}]( t:Tuple${i}[${p(i,"Rep[T%s]")}] ) : Rep[Tuple${i}[${p(i,"T%s")}]]
  def T[${p(i,"T%s")}]( t:Tuple${i}[${p(i,"Rep[T%s]")}] ) = tuple2rep${i}(t)
#end

// enables tuples for groupBy
#for (i <- 1 to max_tuple_size)
  trait IGroupable${i}[${p(i,"T%s")}]{
    def groupBy( f:Tuple${i}[${p(i,"Rep[T%s]")}] => Rep[_] ) : Rep[Iterable[Tuple${i}[${p(i,"Iterable[T%s]")}]]]
  }
  implicit def rep2groupable${i}[${p(i,"T%s")}]( r: Rep[Iterable[(${p(i,"T%s")})]] ) : IGroupable${i}[${p(i,"T%s")}]
#end


#for (i <- 2 to max_tuple_size)
  def zip[${p(i,"T%s")}]( r:Rep[Tuple${i}[${p(i,"Iterable[T%s]")}]] )(implicit o:Overloaded${i}) : Rep[Iterable[Tuple${i}[${p(i,"T%s")}]]]
#end

}

trait Tuples extends ITuples with ModuleBase{
  this: Comprehensions =>

#for (i <- 2 to max_tuple_size)
  case class Zip${i}[${p(i,"T%s")}]( target:Rep[Tuple${i}[${p(i,"Iterable[T%s]")}]] ) extends Generator[Tuple${i}[${p(i,"T%s")}]] with Zip{
    val element = /*replace_with_references(*/ tuple2rep${i}(Tuple${i}(${p(i,"toAtom(Zipped(target._%s))")}))/*, this ) */ // FIXME: is there a bug with references here?
  }
  def zip[${p(i,"T%s")}]( r:Rep[Tuple${i}[${p(i,"Iterable[T%s]")}]] )(implicit o:Overloaded${i}) = Zip${i}(r)
  //not required, because of how scala handles tuples as parameters: //def zip[${p(i,"T%s")}]( ${p(i,"i%s: Rep[Iterable[T%s]]")} ) = Zip${i}(Tuple${i}(${p(i,"i%s")}))
#end

#for (i <- 1 to max_tuple_size)
  implicit def rep2tuple${i}[${p(i,"T%s")}]( t:Rep[Tuple${i}[${p(i,"T%s")}]] ) = {
    //println(rep2def(t))
    //println(rep2def(rep2def(t).asInstanceOf[FieldReference].referree))
    rep2def(t) match {
      case _:FieldReference => rep2def(rep2def(t).asInstanceOf[FieldReference].referree).asInstanceOf[LiftedTuple[_]].p.asInstanceOf[ Tuple${i}[${p(i,"Rep[T%s]")}] ] // FIXME: why is this cast needed?!?
      case _:LiftedTuple[_] => rep2def(t).asInstanceOf[LiftedTuple[_]].p.asInstanceOf[ Tuple${i}[${p(i,"Rep[T%s]")}] ] // FIXME: why is this cast needed?!?
    }
  }
#end

  class LiftedTuple[T]( val p:Product ) extends Def[T]
#for (i <- 1 to max_tuple_size)
  case class LiftedTuple${i}[${p(i,"T%s")}]( t:Tuple${i}[${p(i,"Rep[T%s]")}] ) extends LiftedTuple[Tuple${i}[${p(i,"T%s")}]](t)
  implicit def tuple2rep${i}[${p(i,"T%s")}]( t:Tuple${i}[${p(i,"Rep[T%s]")}] ) = toAtom( LiftedTuple${i}( t ) )
#end

#for (i <- 1 to max_tuple_size)
  case class Groupable${i}[${p(i,"T%s")}]( g:Generator[(${p(i,"T%s")})] ) extends IGroupable${i}[${p(i,"T%s")}]{
    def groupBy( f:Tuple${i}[${p(i,"Rep[T%s]")}] => Rep[_] ) : Rep[Iterable[Tuple${i}[${p(i,"Iterable[T%s]")}]]] = {
      val cols = rep2tuple${i}(replace_with_references(g.element, g))
      val groups = Tuple${i}(
#for (j <- 1 to i)
          ${if(j>1) "," else ""}toAtom(Grouped(cols._${j}))
#end
      )
      new Comprehension[ Tuple${i}[${p(i,"Iterable[T%s]")}] ](
        List[Rep[Iterable[_]]](toAtom(g))
        , replace_with_references(groups, g)
        , groupBy = f(cols) // not: groupBy = replace_with_references(f(cols),g) ???
      )
    }
  }
  implicit def rep2groupable${i}[${p(i,"T%s")}]( r: Rep[Iterable[(${p(i,"T%s")})]] ) = Groupable${i}[${p(i,"T%s")}](rep2generator(r))
#end

    def replace_with_references[R]( r:Rep[_], g:Rep[Iterable[_]], counter : Counter = new Counter(1) ) : Rep[R]= {
      val ref = rep2def(r) match{
        case _:FieldReference => rep2def(r).asInstanceOf[FieldReference]
        case _ => FieldReference(g,counter.count,r)
      }
      val referree = rep2def(ref.referree)
      toAtom(FieldReference(g,counter.count,referree match{
        //case _:SchemaBase => replace_with_references_schema( referree, f )
        case _:LiftedTuple[_] => {
          val p = referree.asInstanceOf[LiftedTuple[_]].p
          def f(x:Int) = {
            replace_with_references[Any]( p.productElement(x-1).asInstanceOf[Rep[_]], g, counter )
          }
          p.productArity match{
            case 1 => tuple2rep1(Tuple1(f(1)))
#for (i <- 2 to max_tuple_size)
            case ${i} => tuple2rep${i}(( ${(1 to i).map( "f("+_+")" ).mkString(", ")} ))
#end
          }
        }
        case _:Generator[_] => {
          /*
          // why is this not needed?
          val gen = referree.asInstanceOf[Generator[_]]
          val refrep = toAtom(ref).asInstanceOf[Rep[Iterable[_]]]
          toAtom(GeneratorReference[Any](
            gen, g, counter
          ))

          //toAtom(ref)*/
          toAtom(new GeneratorReference(
            FieldReference(g,counter.count,toAtom(ref)),
            counter
          ))
        }
        case _ => {
          counter.count+=1
          toAtom(ref)
        }
      })).asInstanceOf[Rep[R]]
    }
/*
    class Synthetic[T] extends Def[T]
    class SyntheticGenerator[T] extends Generator[T]{
        val element = synthesize[T](this,null.asInstanceOf[T])//.asInstanceOf[Rep[T]]
    }
    def synthesize[T]( g:Rep[Iterable[_]], r: T = null ) : Rep[T] = replace_with_references( _synthesize( r ), g )
    def _synthesize[T]( r : T ) : Rep[T] = toAtom( new Synthetic[T] )
    def _synthesize[T]( r : Iterable[T] ) : Rep[Iterable[T]] = toAtom( new SyntheticGenerator[T] )
#for (i <- 1 to max_tuple_size)
    def _synthesize[${p(i,"T%s")}]( r : Tuple${i}[${p(i,"T%s")}] ) : Rep[Tuple${i}[${p(i,"T%s")}]] = tuple2rep${i}(Tuple${i}(${p(i,"_synthesize[T%s](null.asInstanceOf[T%s])")}))
#end
*/
}
